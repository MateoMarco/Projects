# -*- coding: utf-8 -*-
"""function_104143.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ks9JDw_ltF1B2cdKdVIF-OJpLLxMRa1Y
"""

!pip install igraph
import igraph as ig


def function_104143(w):

  #Cargo la informacion conteniendo la relacion entre los edges y cada nodo, asignandoles a cada uno una variable.
  edges = [(1,2), (1,3), (1,4), (2,5), (2,6), (3,2), (3,4), (3,6), (4,6), (4,7), (5,8), (6,5), (6,7), (6,8), (7,8), (1,6)]
  weights = [2305,1241,2117,1149,1032,1157,1430,1969,1293,539,787,1181,945,2453,1435,w]

  #Creo el grafo asignandole la variable g, cargando los edges definidos previamente asignandole a cada uno su peso.
  g = ig.Graph(len(edges), edges)
  g.es["weight"] = weights

  #Resuelvo el problema mediante la funcion get_shortest_paths, indicandole el punto de origen "1", y el destino "to=8"
  path_edges = g.get_shortest_paths(1, to=8, weights=g.es["weight"], output="epath")

  #El retorno de la funcion utilizada es el path indicando cual edge se activo, en orden. Mediante un contador voy sumando las distancias si es que se pudo resolver.
  if len(path_edges[0]) > 0:
      distance = 0
      for e in path_edges[0]:
          distance += g.es[e]["weight"]
      print(f"La distancia mas corta es de: {distance}")
  else:
      print("Error. No se pudo obtener solucion")

  #Si deseo obtener el camino recorrido, junto con las distancias de cada paso, lo extraigo haciendo referencia a las variables utilizadas previamente.
  for i in range(len(path_edges[0])):
    print(f"Paso numero {i+1}: Moverse desde {edges[path_edges[0][i]][0]} hacia {edges[path_edges[0][i]][1]}. Distancia: {weights[path_edges[0][i]]} km") 

  total_optimal_distance = distance

  return total_optimal_distance